%&latex
\section{Main Event Loop}

The main  event loop  in both \textsc{wmRS}  and \textsc{wmCPP}  comprises three
core  stages. They  first  rely on  the underlying  windowing  system to  report
certain \textit{events} they  are interested in. This is  done synchronously, as
without any hardware interrupts or changes  to the environment, nothing is to be
done.  That  is, both  window  managers  \textit{block}  until  a new  event  is
received. The second  stage is the \textit{extraction}  and \textit{bundling} of
useful information from underlying windowing system events into a structure that
can be consumed by the various components of each window manager. The last stage
is using  that windowing system  event information to perform  window management
actions, \textit{delegating work} to different parts of the program.

\subsection{Windowing System Events}

Both \textsc{wmRS} and \textsc{wmCPP} stipulate the existence of a \texttt{step}
method in their  \texttt{Connection} interfaces. This method  is responsible for
converting underlying  windowing system  information into a  higher-level event,
as  can  be  gleaned  from their  signatures:  \mintinline{rust}{fn  step(&self)
->  Option<Event>}   (\textsc{wmRS})  and   \mintinline{cpp}{void  step(Event&)}
(\textsc{wmCPP}), where in both cases  \texttt{Event} is some internally defined
structure of data.

\subsection{Internal Events}

% https://doc.rust-lang.org/book/ch06-00-enums.html

To structure event  data, \textsc{wmRS} uses Rust  \textit{enumerations}. A Rust
\mintinline{rust}{enum}  allows for  the  definition of  a  type by  enumerating
its  variants,  and, aside  from  encoding  \textit{meaning},  is also  able  to
encapsulate  \textit{data}\cite{therustbook}. A  small  part of  \textsc{wmRS}'s
\mintinline{rust}{Event} \mintinline{rust}{enum} looks as follows.

\begin{rustblock}
  pub enum Event {
    Mouse { event: MouseEvent },
    Key { key_code: KeyCode },
    MapRequest { window: Window, ignore: bool },
    FocusRequest { window: Window },
    CloseRequest { window: Window },
    Randr,
    // ...
  }
\end{rustblock}

The   first  five   variants  are   what  are   known  as   \textit{struct-like}
variants   with  named   fields,   whereas   the  last   one   is  a   fieldless
variant  that   comprises  only  an   identifier\cite{therustreference}.  Behind
the   scenes,   each   \mintinline{rust}{enum}  instance   has   an   associated
integer   that  is   used  to   determine  the   underlying  concrete   variant,
known   as  a   \textit{discriminant}\cite{therustreference}.   As  such,   Rust
\mintinline{rust}{enum}s  are  \textit{tagged  unions},  where the  tag  is  the
discriminant.  This   also  means  that  the   size  of  each  instance   of  an
\mintinline{rust}{enum} is determined  by that \mintinline{rust}{enum}'s largest
variant. Rust's  \textit{default representation}  stores the discriminant  as an
\mintinline{rust}{isize}, although the compiler is free to make use of a smaller
type if the amount of variants permits it\cite{therustreference}.\\

% https://en.cppreference.com/w/cpp/utility/variant

A  similar  construct  in   \cpp  is  not  \textit{its}  \mintinline{cpp}{enum},
but   rather   \mintinline{cpp}{std::variant},   a  class   template   available
since  \texttt{C++17}  that  represents  a  type-safe  union\cite{cppstd}.  Just
as  with   Rust's  \mintinline{rust}{enum},  and  similar   to  regular  unions,
the   object   representation   of   the  concrete   variant   held   inside   a
\mintinline{cpp}{std::variant}  instance  is   allocated  entirely  within  that
instance's  object representation\cite{cppstd}.  That  is, the  variant may  not
allocate any additional  dynamic memory\cite{cppstd}. As a result,  just as with
Rust's  \mintinline{rust}{enum}, the  size  of a  \mintinline{cpp}{std::variant}
instance is dependent on its largest variant\cite{cppstd}. \textsc{wmCPP} partly
represents its \mintinline{cpp}{Event} type as follows.

\begin{cppblock}
  typedef std::variant<
    Mouse,
    Key,
    MapRequest,
    FocusRequest,
    CloseRequest,
    Randr,
    // ...
  > Event;
\end{cppblock}

Here,  each  concrete  variant  is a  \cpp  \mintinline{cpp}{struct}  containing
information  about  the  specific  event  that is  being  represented.  This  is
similar to what \textsc{wmRS} does  with its Rust \mintinline{rust}{enum}s, only
more verbose,  non-inlined (as  \mintinline{cpp}{std::variant} cannot  deal with
anonymous \mintinline{cpp}{struct}s), and therefore less structured.

\subsection{Event Dispatch}
% TODO: - language constructs used to handle event dispatch
{ \textcolor{gray}\blindtext }
