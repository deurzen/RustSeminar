%&latex
\section{Input Bindings}
% TODO: - complex feature of which the implementation constructs trickle into
%         many parts of the program (large fan-out)
%       - data structures and language features used to represent key bindings
%       - verbose (kranewm, C++) vs use of macros (wzrd, Rust)

% https://locka99.gitbooks.io/a-guide-to-porting-c-to-rust/content/features_of_rust/macros.html

Key and mouse bindings are the central point of interaction between the user and
the window  manager. At a high  level, as the  name would suggest, they  work by
\textit{binding} to sets of \textit{input  states}. These input states typically
comprise  keyboard  (i.e., \textit{which  keys  are  pressed down?})  and  mouse
(\textit{which mouse  buttons are pressed  down?}) inputs, but can  in principle
come from  any kind  of peripheral  input source, such  as sensors.  Since input
readings  are hardware  and, transitively,  platform dependent,  both \wmrs  and
\wmcpp rely  on the  connection with  the windowing  system to  facilitate these
bindings. That is---as can be seen from the \texttt{Connection} interfaces given
in  the examples  above---both  window managers  receive  specific events  (e.g.
\texttt{Key} and  \texttt{Mouse}) that communicate  that a specific  binding has
been activated.

To  attach  window  management  activities  to these  key  and  mouse  bindings,
\textsc{wmRS} uses a Rust \mintinline{rust}{HashMap}  to map resp. mouse and key
input  state  abstractions to  \textit{closures}  that  call  into part  of  the
\texttt{Model}.  Mouse  input abstractions  look  something  like the  following
(parts redacted for clarity).

\begin{rustblock}
  pub enum MouseEventKind {
    Press, Release, Motion,
  }
\end{rustblock}

\vspace{0.15cm}
\begin{minipage}{0.45\linewidth}
\begin{rustblock}
pub enum Button {
  Left,
  Middle,
  Right,
  ScrollUp,
  // ...
}
\end{rustblock}
\end{minipage}
\begin{minipage}{0.50\linewidth}
\begin{rustblock}
pub enum Modifier {
  Ctrl,
  Shift,
  Super,
  Alt,
  // ...
}
\end{rustblock}
\end{minipage}\\

\begin{rustblock}
  pub struct MouseInput {
    pub button: Button,
    pub modifiers: HashSet<Modifier>,
  }
\end{rustblock}

\begin{rustblock}
  pub struct MouseEvent {
    pub kind: MouseEventKind,
    pub input: MouseInput,
    pub window: Option<Window>,
  }
\end{rustblock}

Again,  \textsc{wmRS} relies  on the  connection  with the  windowing system  to
establish the mapping from concrete  underlying window system input encodings to
the abstractions  above. In  particular, we expect  a \texttt{MouseEvent}  to be
fired (and propagated up through \texttt{Connection::step}) whenever a button is
pressed.  The  event's input  \textit{modifiers}  are  contained within  a  Rust
\texttt{HashSet},  as  ordering  and  possible duplicates  are  irrelevant.  Its
\texttt{window}  field is  to optionally  contain the  unique identifier  of the
window  that was  clicked on  (if any).  The representation  of key  bindings is
similar to the above, but instead  of mouse buttons it includes non-modifier key
identifiers.

The actual  mapping between these input  abstractions and hooks into  the window
manager's \texttt{Model} then looks as follows.

\begin{rustblock}
  pub type KeyAction = Box<
    dyn FnMut(&mut Model<'_>)
  >;
\end{rustblock}
\begin{rustblock}
  pub type MouseAction = Box<
    dyn FnMut(&mut Model<'_>, Option<Window>)
  >;
\end{rustblock}
\begin{rustblock}
  pub type KeyBindings = HashMap<
    KeyInput, KeyAction
  >;
\end{rustblock}
\begin{rustblock}
  pub type MouseBindings = HashMap<
    MouseInput, MouseAction
  >;
\end{rustblock}

These  are   simple  \textit{type  alias}  declarations,   giving  existing  (in
this  case  compound)  types  a  new name.  The  first  two  represent  closures
that   hook   into   (i.e.   take   as   parameter)   a   \textit{mutable}---or,
more  semantically  explicative:  \textit{exclusive}---reference  to  the  model
instance\cite{therustbook}. \mintinline{rust}{FnMut}  is a trait  that describes
the calling of a function that  is allowed to change (\textit{mutate}) state; it
permits its  implementors to use  call syntax, such that  they can act  and look
like  regular  function  pointers. \mintinline{rust}{Box}  \textit{boxes}  up  a
value, storing  it on the heap  and yielding a  pointer to it (under  the hood).
Specifically,  here, that  means  that \textit{some}  type  that implements  the
\mintinline{rust}{FnMut} trait and takes a mutable reference to a model instance
(\mintinline{rust}{dyn FnMut(&mut  Model<'_>)}) is  boxed up  and stored  on the
heap  for  future  reference.  We require  the  use  of  \mintinline{rust}{Box},
as   we  want   to   be  able   to  store   \textit{any   implementor}  of   the
\mintinline{rust}{FnMut} trait. To do so, Rust will rely on dynamic dispatch, as
the size of the implementor object is  not known until runtime, and it therefore
cannot  be stored  on the  stack\cite{rustclosureshard}. The  advantage of  this
approach  is that  it facilitates  the changing  of input  bindings at  runtime,
allowing  for  multi-hierarchical  input  bindings, as  well  as  user-initiated
binding customization without requiring program restart.


% Discuss {Build,}Hashers -> more efficient as we have unique keys (input bindings),
% therefore we don't require complex collision safety etc.
