%&latex
\section{Conclusion}

In this seminar, we have compared Rust and \cpp in their \textit{pragmatics}
when writing medium to large system software. Specifically, we have sought to
achieve \textit{the same objective} using both languages: the implementation of
a window manager. In doing so, we have discussed four core phases in the design
of such software: external dependency management, the main event loop and event
dispatch, input bindings and the storage of callable objects, and, finally, the
central storage and distributed mutating of state.

While Rust is able to make certain guarantees in regard to memory safety and
data races---making it an eminently safer choice compared to \cpp---it is
additionally often able to capture in its syntax more concisely and eloquently
the semantics required to achieve an objective. This has much to do with its
more minimal and simplistic, but at the same time more expressively powerful
language features, such as, for example, the pattern matching constructs
reminiscent of functional languages, or its tagged union enumerations. Another
decisive factor in Rust's perceived efficacy is its \textit{consistency}.
Whereas \cpp offers operator overloading through a multitude of constructs
(varying from class methods to concrete template class implementations), Rust
does so \textit{solely} through trait implementations.

Rust's safety guarantees indeed make the language demonstrably superior from
an \textit{error mitigation} point of view. However, those guarantees can at
times still come at a cost in light of its pragmatics. Assuming memory safety
assertions are properly taken care of, dealing with references can be much
easier in \cpp than in Rust. Due to the fact that Rust's borrow checking system
is more restrictive than strictly necessary, certain programming patterns are
unable to be used, such as, for instance, self-referential structures. In
fact, Rust even has \textit{interior mutability} constructs just to improve
programming flexibility, something \cpp has by default.

All in all, the Rust programming language is the product of learning from years
and years of how best \textit{not} to do it, while at the same time borrowing
features from languages that \textit{did} get it right. Due to the complexity
and strictness of its borrow checking system, the developers have sought to
keep the core language as simple yet expressive as possible. \cpp, on the other
hand, lacks in its design the \textit{hindsight} Rust has profited from so much,
and is in comparison immensely complex---some would even say convoluted. This
results from decades of revisions that add new, powerful language features,
which are all required to coexist nicely with older constructs that were
initially not designed to cater to these new features, all the while maintaining
the design goals of the initial core language.
