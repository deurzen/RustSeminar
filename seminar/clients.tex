%&latex
\section{Clients}
% TODO: - main data structure that represents a window under window manager
%         control
%       - wrapper around X11 window
%       - directly manipulated by practically all parts of the program
%       - reason for pointer (C++) vs id (Rust) representation

So far, the notion of a \textit{window} was used throughout without defining
what exactly it is to entail. In both \textsc{wmRS} and \textsc{wmCPP}, a
\texttt{Window} is a unique identifier (e.g., an unsigned integer) for a
window that, again, maps windowing system specific representations to an
abstraction that is to be used within the window manager. A window in and of
itself therefore does not contain any \textit{state}. To associate state with a
window, we wrap around it a structure that we call a \textit{client}. Clients
are objects that contain all relevant information about a window: its title,
position and size on-screen, process identifier, whether it is in fullscreen
mode, and much more.

\rssubsection{Mutable State with Cell and RefCell}

We have thus far deferred discussing a major aspect of the Rust programming
language: \textit{mutability}. Rust's \rsin{mut} keyword carries two kinds
of semantics, depending on where it is used. In patterns, \rsin{mut} indeed
indicates that changing the underlying value is allowed. In references, however,
it rather pertains to \textit{exclusivity}. That is, a \rsin{&mut} reference may
be mutated, but additionally is not allowed to be \textit{aliased}. Consider
part of \textsc{wmRS}'s \rsin{Client} structure:

\begin{rustblock}
  pub struct Client {
    window: Window,
    workspace: Cell<usize>,
    parent: Option<Window>,
    children: RefCell<Vec<Window>>,
    fullscreen: Cell<bool>,
    // ...
  }
\end{rustblock}

We want to pass around references to instances of this structure throughout the
\rsin{Model}, to read and alter state, and to make window management decisions
accordingly. Disregarding the concrete contents of the \rsin{Client} structure
for a moment, one possibility would be to have the different client-mutating
methods that are part of the \rsin{Model} operate on a \rsin{&mut Client}. While
this is a plausible approach, it heavily limits us in using and passing around
references as, in concreto, no more than a single reference to a to-be-mutated
\rsin{Client} may then exist at a time. This becomes particularly troublesome,
as we need to store \rsin{Client} instances within the \rsin{Model}, mapping
window representations to their associated \rsin{Client} structure, as follows:

\begin{rustblock}
  pub struct Model<'model> {
    client_map: HashMap<Window, Client>,
    // ...
  }
\end{rustblock}

Since mutability transitively affects all surrounding structures, mutating a
single field within a \rsin{Client} instance means that the reference to that
instance would have to be \rsin{&mut}. This additionally requires that the
\rsin{Model}'s method that retrieves from its \rsin{client_map} and operates on
such an instance would \textit{also} have to take \rsin{&mut self}. For this
reason, this kind of mutability is what's known in Rust as \textit{inherited}
mutability, also referred to as \textit{external} mutability.

Considering that the windowing system generates events in respect to some
\textit{window}, whenever we need to alter the state that is associated with
that window, we must therefore first retrieve a mutable reference to its client
from the \rsin{client_map}. A result of this, is that something like the
following would not be possible:

\begin{rustblock}
  impl<'model> Model<'model> {
    fn set_fullscreen_window(&mut self, win: Window) {
      if let Some(c) = self.client_map.get_mut(&win) {
        c.set_fullscreen(true);
        self.apply_layout(c.workspace());
      }
    }
\end{rustblock}
\begin{rustblock}
    fn apply_layout(&self, index: usize) { /* ... */ }
    // ...
  }
\end{rustblock}

Even though \rsin{apply_layout} can be called on a non-exclusive
reference to the model (i.e. it takes \rsin{&self}), the
above will not compile: An immutable borrow of \rsin{self}
(\rsin{|\bfseries{self}|.apply_layout(c.workspace())}) occurs \textit{after}
a mutable one (\rsin{|\bfseries{self}|.client_map.get_mut(&win)}) inside
\rsin{set_fullscreen_window}, which is not allowed due to the exclusivity rules
discussed before. Because every method that directly manipulates a client has a
structure analogous to the \rsin{set_fullscreen_window} method, this approach is
not viable.

To solve this, we use a technique called \textit{interior mutability}. Interior
mutability enables the mutating of an underlying structure of data with a
\textit{non-exclusive} reference to it, therein defying the requirement that
only exclusive references may be mutated. To facilitate this, four language
constructs exist: \rsin{Cell} and \rsin{RefCell} for single-threaded solutions,
and \rsin{Mutex} and \rsin{RwLock} as their thread-safe alternatives.

In view of the fact that window managers operate on an \textit{ordered} stream
of events, they function well as event-driven, single-threaded applications.
To that end, each \rsin{Client} field that is expected to mutate throughout
program execution---representing state changes instigated by windowing system
events---gets wrapped inside either a \rsin{Cell} or a \rsin{RefCell}.
\rsin{Cell} deals solely with \textit{values}: values are moved or copied
into the cell, or retrieved from it as a whole. Retrieving a reference to
the contents of a \rsin{Cell} is not possible. \rsin{RefCell}, on the other
hand, works exclusively with \textit{references}, and implements so-called
\textit{dynamic borrowing}. That means that access to mutable references to
the contents of a \rsin{RefCell} are tracked \textit{at runtime}, which may
cause a panic if a second mutable borrow is attempted while another is already
outstanding. Compared to \textit{static borrowing}, at a slight runtime cost,
dynamic borrowing permits much more flexible use of references, since the
compiler is only able to perform borrow checks at a rather coarse level of
granularity.

From a pragmatics point of view, what \rsin{Cell} and \rsin{RefCell} allow us to
do, is to instead take as parameter a non-exclusive \rsin{&Client} as parameter,
and mutate individual fields, therein enabling reference aliasing \textit{and}
retaining mutability. Consider the following \rsin{Client} method:

\begin{rustblock}
  impl Client {
    pub fn set_fullscreen(&self, bool: value) {
      // copy `value` into the Cell
      self.fullscreen.set(value);
    }
    // ...
  }
\end{rustblock}

Thanks to interior mutability, to be able to call this method on a \rsin{Client}
reference, that reference does not need to be exclusive (due to it operating
on \rsin{&self} instead of \rsin{&mut self}). This allows us to rewrite the
\rsin{set_fullscreen_window} method, as follows:

\begin{rustblock}
  fn set_fullscreen_window(&self, win: Window) {
    if let Some(c) = self.client_map.get(&win) {
      c.set_fullscreen(true);
      self.apply_layout(c.workspace());
    }
  }
\end{rustblock}

% TODO: discuss problem of Rust mutability -> decourages encapsulation: even though 1 field needs to change, reference to _whole_ structure needs to be mutable

% https://stackoverflow.com/questions/63487359/interior-mutability-abuse-in-api-design#:~:text=Conversely%2C%20C%2B%2B%20has%20nothing%20like,implicitly%20behind%20an%20UnsafeCell%20already.
