%&latex
\section{External Dependency Management}

As a programming  language's ability to aid the programmer  in managing external
dependencies---by,  for instance,  providing various  tools that  come installed
with  its compiler  or development  environment---is generally  not incorporated
into that language's syntax or, by extension, its semantics, it is traditionally
not considered an aspect of that language's feature set per se. Notwithstanding,
it is more  and more becoming an appreciated addition  to the \textit{ecosystem}
around a  language, especially so  for compiled  languages. In fact,  many would
consider automated  external dependency management to  be a must for  any modern
programming language.  As it directly affects  both the portability of  code, as
well as the (ease of) managing  different versions of a dependency, a language's
ability  to unburden  the  programmer  from the  manual  management of  external
dependencies  can greatly  improve the  maintainability  of a  project, and  can
therefore  indeed be  viewed  as a  feature  of  the language  in  light of  its
\textit{pragmatics}. In this  section, we will be  discussing the practicalities
of working with external code in both  Rust and C\texttt{++}. We will do this by
means of a comparison between two window manager implementations, one written in
Rust,  and the  other  written  in C\texttt{++},  which  we  will henceforth  be
referring to as \textsc{wmRS} and \textsc{wmCPP}, respectively.

Both  window managers  are built  on top  of the  X Window  System, which  means
they  rely on  an external  library  to interface  with the  X server.  Although
\textsc{wmRS} and  \textsc{wmCPP} each use  a different library to  achieve this
(XCB  over \texttt{libxcb}  and  Xlib over  \texttt{libX11}, respectively),  the
concept is the same,  as they both require the importing of  an external body of
code.\\

C\texttt{++} does not come with an  external dependency manager. That is to say,
the  official  ISO  standard C\texttt{++}  specification\cite{cppstd}  does  not
outline the  functionality or otherwise existence  of any package manager.  As a
result, developers have  no other choice than to resort  to third-party tools to
manage  dependencies,  to  reinvent  the  wheel  themselves  and  hack  together
configure and build scripts that take  external dependencies into account, or to
disregard package management  altogether and let other developers  and end users
resolve  dependencies  on  their  own.  In  any  case,  C\texttt{++}  dependency
management is complex, and the lack of a standardized tool inhibits the adoption
of C\texttt{++}  projects, as well as  their portability to other  platforms and
development environments.

Since   the  only   external  dependency   \textsc{wmCPP}  is   reliant  on   is
\texttt{libX11},  which  is  fairly  ubiquitous and  readily  available  through
distributions'   own  package   managers,   it  merely   links   with  the   X11
development  libraries   without  the  use   of  any  form  of   own  dependency
management.  Specifically, building  the  project is  done  using the  following
\textbf{\texttt{Make}} script (large parts altered or redacted for clarity).

\begin{minted}[fontsize=\small]{make}
  CC = g++
  CXXFLAGS = -std=c++17 -march=native -O3
  LDFLAGS = `pkg-config --libs x11` -flto

  obj/%.o: src/%.cc
    ${CC} ${CXXFLAGS} -MMD -c $< -o $@
  release: obj/%.o
    ${CC} $< ${LDFLAGS} -o bin/wmCPP
\end{minted}

Assuring the availability of an external body  of code is not the only aspect of
external  dependecy  management that  affects  the  pragmatics of  C\texttt{++}.
Writing a library that is to be imported as an external dependency and including
code from an external  dependency both require special care to  be taken to make
sure no symbol collisions occur. In header files, this is usually done by making
use of so-called  \textit{header guards}, a set of  preprocessor directives that
render including a  header an idempotent operation,  preventing double inclusion
errors. If incorrect double inclusion  does unexpectedly occur, for instance due
to  collisions in  the header  guards themselves,  vague---as header  guards are
handled  by  the preprocessor,  not  the  compiler---and hard-to-trace  compiler
errors  arise,  subjecting the  programmer  to  unnecessary mental  strain,  and
wasting  time. Although  not part  of the  official standard,  many C\texttt{++}
compilers  support the  \mintinline{cpp}{#pragma once}  preprocessor  directive,
providing the same functionality as header guards, but preventing the occurrence
of double inclusion errors.

Another source of issues is the order of include directives in C\texttt{++}. The
ordering of included  files relative to one another  can significantly influence
the outcome of the compilation step, possibly causing errors, one of which being
the introduction of circular dependencies  while there actually aren't any there
(e.g. a forward declaration that was included only after the circular dependency
was already introduced).\\

% https://doc.rust-lang.org/cargo/guide/

The Rust programming  language has its own package manager,  called Cargo. Cargo
can automatically download a project's external dependencies (and, transatively,
\textit{their} dependencies), compile them, and  install them locally, such that
they can be  used during the linking  stage of the build  process[CITE]. To make
proper use of  Cargo within a Rust  project, that project must be  turned into a
so-called  \textit{package}. Rust  packages are  simply a  collection of  source
files along  with a manifest  file (named \texttt{Cargo.toml}) in  the project's
root  directory. This  manifest  file describes  the package's  meta-information
(such as its name and version), and  a set of \textit{target crates}. A crate is
the source code or compiled artifact  of either a library or executable program,
or possibly a compressed package that is grabbed from a registry (a service that
provides  a  collection  of  downloadable crates).  A  package's  manifest  file
describes each of its target crates  by specifying their type (binary executable
or library), their metadata, and how to build them[CITE].

The  following manifest  file describes  the  package that  represents our  Rust
window manager, \textsc{wmRS} (parts redacted for clarity).

\begin{minted}[fontsize=\small]{shell}
  [package]
  name = "wmRS"
  version = "0.1.0"
  authors = ["deurzen <m.deurzen@tum.de>"]
  edition = "2018"
  license = "BSD3"
  documentation = "https://docs.rs/wmRS"
  readme = "README.md"
  default-run = "wmRS"
  description = """
  An ICCCM & EWMH compliant X11 reparenting,
  tiling window manager, written in Rust
  """
  [profile.release]
  lto = true
  [lib]
  name = "winsys"
  path = "src/winsys/mod.rs"
  [[bin]]
  name = "wmRS"
  path = "src/core/main.rs"
  [[bin]]
  name = "wmRSbar"
  path = "src/bar/main.rs"
  [[bin]]
  name = "wmRSclient"
  path = "src/client/main.rs"
  [dependencies]
  x11rb = {
    version = "0.8.0",
    features = [
      "cursor",
      "xinerama",
      "randr",
      "res"
    ]
  }
\end{minted}

% https://doc.rust-lang.org/book/ch10-02-traits.html
% https://doc.rust-lang.org/rust-by-example/trait.html
% https://blog.logrocket.com/rust-traits-a-deep-dive/
% https://doc.rust-lang.org/book/ch19-03-advanced-traits.html

Our  package  consists  of  a  single  library  crate  (\texttt{winsys}),  along
with  three  binary  executable  crates  (\texttt{wmRS},  \texttt{wmRSbar},  and
\texttt{wmRSclient}). The library is an abstraction above and wrapper around the
interface  with  the underlying  windowing  system.  It  defines a  single  Rust
\textit{trait} that  represents the  connection between  the window  manager and
some windowing system.  A trait is a  \textit{zero-overhead}[CITE] collection of
methods that  is defined  for some (at  define-time) unknown  type \texttt{Self}
(which at  implementation-time becomes the  implementing type), most  often used
with the intention to implement shared behavior[CITE,CITE]. A concept from other
languages that  most closely resembles traits  are \textit{interfaces}, although
there are differences  still[CITE]. A small snippet  from \textsc{wmRS}'s winsys
library \texttt{Connection} trait looks as follows.

\begin{minted}[fontsize=\small]{rust}
  pub trait Connection {
    fn step(&self) -> Option<Event>;
    fn close_window(&self, window: Window) -> bool;
    fn move_window(&self, window: Window, pos: Pos);
    fn resize_window(&self, window: Window, dim: Dim);
    fn focus_window(&self, window: Window);
    // ...
  }
\end{minted}

Here, we've  supplied a set  of function  prototypes that eventually  become the
methods that every  type that implements this trait will  be required to define.
Although we haven't  done so here, traits themselves are  also allowed to define
their functions with  some default behavior, that may or  may not be overwritten
by  its  implementors[CITE].  Our \texttt{Connection}  trait  represents  shared
behavior that every windowing system wrapper is required to contain. This allows
for the decoupling  of the implementation of the  higher-level window management
functionality from  that of the  interface with  the windowing system  (e.g. the
explicit drawing of primitives to the screen, or the management and manipulation
of windowing  system specific  window representations), and  additionally allows
for the  seamless transition from one  windowing system to another,  as multiple
windowing  systems  can  be  targeted by  implementing  the  trait,  effectively
creating a new wrapper around an  external library that directly interfaces that
windowing system.  Currently, \textsc{wmRS}  only implements the  interface with
the X Window System,  but interfacing with the newer and  more modern Wayland is
as easy as  implementing a new connection to  it. \textsc{wmRS}'s implementation
for this trait, targeting the X Window System, is partly given as follows.

\begin{minted}[fontsize=\small]{rust}
  use x11rb::connection;
 
  pub struct XConnection
    <'conn, Conn: connection::Connection>
  {
    conn: &'conn Conn,
    // ...
  }
 
  impl<'conn, Conn: connection::Connection>
    Connection for XConnection<'conn, Conn>
  {
    #[inline]
    fn step(&self) -> Option<Event> {
      // ...
    }
    // ...
  }
\end{minted}

The  \texttt{XConnection}  structure  introduces  two  generic  type  arguments,
one  being   a  lifetype  parameter   (\texttt{'conn}),  and  the   other  being
the   type  of   the   struct's  \texttt{conn}   field  (\texttt{Conn}),   which
\textit{requires} the  \texttt{connection::Connection} trait to  be implemented.
This \texttt{connection::Connection} trait is imported from the external package
\texttt{x11rb}, which we supplied as a  project dependency in our manifest file.
The  \texttt{x11rb}  package serves  as  a  Rust API  to  the  X Window  System,
effectively  providing us  with Rust  bindings to  interact with  the X  server.
Finally,  the  \texttt{XConnection}  struct implements  our  previously  defined
\texttt{Connection} trait, allowing it to be used by our window manager by means
of composition.  Given below is  the structure that represents  and encapsulates
the core window manager logic. It \textit{contains} a reference to \textit{some}
type  that  implements our  \texttt{Connection}  trait  (i.e. a  wrapper  around
\textit{some} windowing system).

\begin{minted}[fontsize=\small]{rust}
  pub struct Model<'model> {
    conn: &'model mut dyn Connection,
    // ...
  }
\end{minted}

% https://doc.rust-lang.org/1.8.0/book/trait-objects.html#static-dispatch
% https://doc.rust-lang.org/1.8.0/book/trait-objects.html#dynamic-dispatch
% https://doc.rust-lang.org/book/ch10-01-syntax.html#performance-of-code-using-generics

Since  we're  using  polymorphism  here   to  abstract  away  from  the  actual,
concrete  implementation  of  the  connection   type,  Rust  needs  to  be  able
to  determine  at  runtime  which   specific  version  it  should  actually  run
(known  as \textit{dispatch})[CITE].  It  can do  so either  \textit{statically}
or   \textit{dynamically}.    Static   dispatch    in   Rust   makes    use   of
\textit{monomorphization}  at   compile  time  to  convert   generic  code  into
``specific'' code: one version for each concrete type that is used as a generics
argument.  That means  that  at runtime,  no (time)  overhead  is incurred  when
running generic code, as the specific versions of the code to run are baked into
the binary.  An example  of static  dispatch in  \textsc{wmRS} is  the following
\texttt{Cycle} struct, which  allows for cycling forward and  backward through a
collection of (generic) items.

\begin{minted}[fontsize=\small]{rust}
  pub struct Cycle<T>
  where
    T: Identify + Debug,
  {
    index: Cell<Index>,
    elements: VecDeque<T>,
    indices: HashMap<Ident, Index, BuildIdHasher>,
    unwindable: bool,
    stack: RefCell<HistoryStack>,
  }

  impl<T> Cycle<T>
  where
      T: Identify + Debug,
  {
    // ...
  }
\end{minted}

This  struct is  used to  cycle through  both the  workspace structures  managed
by  the  window  manager, as  well  as  the  clients  within a  workspace.  That
means  two specific  versions of  this struct  are constructed  at compile-time:
one  for \mintinline{rust}{Workspace},  and  one for  \mintinline{rust}{Client},
where  \mintinline{rust}{Workspace} and  \mintinline{rust}{Client} in  turn both
implement  the \mintinline{rust}{Identify}  and \mintinline{rust}{Debug}  traits
(as per the constraint on \mintinline{rust}{T}).

% https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait
% https://doc.rust-lang.org/book/ch17-02-trait-objects.html

Dynamic dispatch defers resolving generic code  until it is required at runtime,
making use  of so-called  \textit{trait objects}.  A trait  object is  an opaque
value of a type  that implements some set of traits. It's  opaque, as one cannot
know which  concrete type is behind  a trait object's pointer  up front. Whereas
the size of each monomorphized type is always known, trait objects are therefore
dynamically  sized.  To  resolve  a  call  to  one  of  such  an  opaque  type's
methods at runtime, \textit{virtual  method tables} (\textit{vtables}) are used.
Each  instance  of  a pointer  to  a  trait  object  consists of  a  pointer  to
an  instance  of some  type  \mintinline{rust}{T}  that  implements the  set  of
traits,  as well  as a  pointer to  a vtable  that contains  a function  pointer
to  \mintinline{rust}{T}'s  implementation of  each  method  of the  implemented
set  of traits  (and their  supertraits). Our  \mintinline{rust}{Model} struct's
\mintinline{rust}{conn} field  is a pointer to  such a trait object.  Behind the
pointer,  we can  have any  implementation of  the \mintinline{rust}{Connection}
trait. Which of  the trait's implementors' methods are called,  is determined at
runtime.

Looking  back at  \textsc{wmRS}'s  manifest file,  the  three binary  executable
crates in its package respectively represent the window manager itself, a client
program  to communicate  with  the  window manager  (to  control various  window
management  activities,  such as  closing  the  currently focused  window,  from
scripts or the  command line), and a status bar  that displays information about
the state of the window manager, such as the currently activated workspace. Each
make use  of the  winsys library  to communicate  with the  underlying windowing
system.\\

Our  C\text{++}  window  manager  implementation,  \textsc{wmCPP},  attempts  to
achieve  the  same  flexibility  by making  use  of  \textit{abstract  classes}.
Abstract classes  define abstract types  that cannot themselves  be implemented,
but  are instead  used  to establish  a common  denominator  between types  that
should  present shared  behavior. Abstract  classes can  mimick the  behavior of
interface constructs  in languages such  as Java by declaring  only \textit{pure
virtual}  methods. Pure  virtual  methods are  methods that  do  not expose  any
associated  inline  logic, and  as  such  \textit{must}  be implemented  by  any
inheriting  subclasses.  Consider \textsc{wmCPP}'s  \mintinline{cpp}{Connection}
abstract class.

% https://en.cppreference.com/w/cpp/language/abstract_class

\begin{minted}[fontsize=\small]{cpp}
  class Connection
  {
  public:
    virtual ~Connection() {}
  
    virtual void step(Event&) = 0;
    virtual bool close_window(Window) = 0;
    virtual void move_window(Window, Pos) = 0;
    virtual void resize_window(Window, Dim) = 0;
    virtual void focus_window(Window) = 0;
    // ...
  };
\end{minted}

The fact  that this  class contains  \textit{at least}  a single  virtual method
declaration  without an  inline  implementation (i.e.,  its declaration  appears
to  be  assigned to  zero),  makes  it an  abstract  class.  When not  a  single
method  (except  for possibly  its  constructor  or  destructor) has  an  inline
implementation, that class is considered to be a proper interface.

Although   an  abstract   class's  pure   virtual  methods   cannot  be   called
\textit{dynamically}  (i.e., using  virtual  dispatch), it  may still  implement
associated logic  that can subsequently be  called \textit{statically}. Consider
part of \mintinline{cpp}{Connection}'s implementation.

% https://stackoverflow.com/a/12855410/11069175
% https://stackoverflow.com/questions/5481941/c-pure-virtual-function-have-body

\begin{minted}[fontsize=\small]{cpp}
  #include "connection.hh"
  #include "log.hh"

  // ...
  void
  Connection::focus_window(Window window)
  {
    Logger::log_info("Focusing window %s.",
      window.to_string());
    // ...
  }
  // ...
\end{minted}

Calling  a virtual  function statically  (non-virtually)  is done  by using  its
qualified name in the call. This  is especially useful for implementors (derived
classes)  that all  share  an identical  part  of code.  In  our example  above,
regardless  of the  underlying  windowing system,  the logging  of  an event  is
identical,  and  can  thus  be  part of  the  abstract  class's  implementation.
Performing  the call  from \textsc{wmCPP}'s  \mintinline{cpp}{XConnection} class
would look as follows.

\begin{minted}[fontsize=\small]{cpp}
  #include "connection.hh"

  // ...
  class XConnection final: public Connection
  {
  public:
    // ...
    void focus_window(Window window) override {
      // non-virtual call
      Connection::focus_window(window);
      // ...
    }
    // ...
  };
  // ...
\end{minted}

As  can be  seen in  the above  example, providing  a concrete  implementing for
our  abstract  notion of  a  connection  is done  through  \textit{inheritence}.
Each  wrapper   around  the  connection  with   \textit{some}  windowing  system
will   be  represented   as   a   class  that   inherits   (derives)  from   the
\mintinline{cpp}{Connection}   abstract  class,   providing  an   implementation
specific to that windowing system.

\textsc{wmCPP}'s  \mintinline{cpp}{Model}  class  will then  \textit{contain}  a
reference  to \textit{some}  implementation of  \mintinline{cpp}{Connection}, as
follows.

\begin{minted}[fontsize=\small]{cpp}
  #include "connection.hh"

  // ...
  class Model final
  {
  public:
    Model(Connection& conn): conn(conn) {
      // ...
    }
    // ...
  private:
    Connection& conn;
    // ...
  };
\end{minted}

Just  as in  our  Rust  implementation, \mintinline{cpp}{conn}'s  implementation
details  will be  resolved only  at runtime,  when they  are needed,  making use
dynamic dispatch (through a similar vtable mechanism).\\

% https://blog.rust-lang.org/2015/05/11/traits.html

While   in  our   window  manager   implementations  both   Rust's  traits   and
C\texttt{++}'s abstract classes appear to  achieve the same objective in similar
fashion, the constructs  themselves are very different.  For one, implementation
(traits) is not the same as inheritence (abstract classes).

Within a crate, owned traits can be implemented for external (and even built-in)
types.
